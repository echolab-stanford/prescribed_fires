import numpy as np
import pandas as pd
import rasterio
import xarray as xr
import rioxarray


def expand_grid(dict_vars):
    """Create cartesian product of a set of vectors and return a datafarme

        This function calculates the cartesian product of a set of vectors and
        return a tabular data structure, just as R's expand.grid function.
    a
        Parameters
        ----------
        dict_vars : dict
            Dictionary containing the vectors to be combined. The keys are the
            column names and the values are the vectors.

        Returns
        -------
        pandas.DataFrame
            Dataframe containing the cartesian product of the vectors
    """
    mesh = np.meshgrid(*dict_vars.values())
    data_dict = {var: m.flatten() for var, m in zip(dict_vars.keys(), mesh)}

    return pd.DataFrame(data_dict)


def transform_array_to_xarray(data, transform, extra_dims=None):
    """Transform numpy array to xarray using an affine transform (from rasterio)

    This function takes a numpy array with a transform affine matrix and return
    an xarray with latitude and longitude coordinates and extra dimensions if
    passed.

    TODO:
    ----
    CRS is not passed as an option, but that would be a nice addition!

    Parameters
    ----------
    data : np.array
        Array with data
    transform : affine.Affine
        Affine transform matrix
    extra_dims : list, optional
        List with extra dimensions to add to the xarray

    Returns
    -------
        An xarray with the data and coordinates
    """

    height = data.shape[0]
    width = data.shape[1]

    cols, rows = np.meshgrid(np.arange(width), np.arange(height))
    xs, ys = rasterio.transform.xy(transform, rows, cols)

    # Concat into arrays
    lons = np.array(xs)
    lats = np.array(ys)

    # Create xarray
    coords = {"lat": lats[:, 0], "lon": lons[0, :]}

    if extra_dims:
        coords.update(extra_dims)

        # Take care of array dimensions. Dimensions should be at minimum 2D
        # by construction. If extra dims are passed, we need to add a new axis
        # to the data array if the data is not there.
        # For example:
        # data.shape = (10, 10) # lon and lat
        # data.shape = (10, 10, 1) # lon, lat and time.
        # We need to pass an array with the last shape if we have extra dims.

        extra_dims_len = len(extra_dims)

        if len(data.shape) == 2:
            data = data[(...,) + (np.newaxis,) * extra_dims_len]

    return xr.DataArray(data, coords=coords, dims=list(coords.keys()))


def prepare_template(template_path, years=[2000, 2023]):
    """Aux function to prepare the template as a cartesian product of time and space

    This function expects a raster template with 1 for land and 0 for water as
    the one generated by the `prepare_template` function in the `src/data` module.
    The function will create a cartesian product of time and space to create a
    template with all the pixels in the sample.

    Args:
        template_path (str): Path to the template raster
        years (list): List with the first and last year of the sample: [start, end]

    Returns:
        pd.DataFrame
    """

    # Load template to start merging
    template = rioxarray.open_rasterio(template_path)

    # Notice template is 1 for land and 0 for water
    template_df = (
        template.rename({"x": "lon", "y": "lat"})
        .to_dataframe(name="id_template")
        .reset_index()
        .dropna()
    )
    template_df["grid_id"] = template_df.index

    # Remove the water pixels
    template_df = template_df[template_df.id_template == 1]

    # Create grid for all years in the sample: cartesian product of time and
    # observations
    template_expanded = expand_grid(
        {"grid_id": template_df.grid_id, "year": np.arange(years[0], years[1] + 1)}
    )

    # Add lat and lon to the expanded grid
    template_expanded = template_expanded.merge(
        template_df[["grid_id", "lat", "lon"]], on="grid_id"
    )

    return template_expanded
